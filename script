// Скрипт для переноса данных из PDF-отчета ПИК в Miro
// Для использования нужно создать приложение/плагин в Miro

// Инициализация Miro SDK
miro.onReady(() => {
  // Добавляем пункт меню в Miro
  miro.initialize({
    extensionPoints: {
      bottomBar: {
        title: 'Импорт из ПИК-отчета',
        svgIcon: '<circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2"/>',
        onClick: showImportDialog
      }
    }
  });
});

// Структура данных для сопоставления разделов отчета с секциями на доске Miro
const reportSections = {
  'Демография': {
    startMarker: '1. Демография (Усредненная/Типичная)',
    endMarker: '2. Поведение и Привычки',
    titleMatcher: /демограф|профиль персоны/i
  },
  'Поведение': {
    startMarker: '2. Поведение и Привычки (Типичные при покупке жилья)',
    endMarker: '3. Психологический Портрет',
    titleMatcher: /поведение|привычк/i
  },
  'Психологический Портрет': {
    startMarker: '3. Психологический Портрет (Преобладающий/Типичный)',
    endMarker: '4. Ключевые Критерии Выбора Квартиры',
    titleMatcher: /психологический портрет|психотип/i
  },
  'Критерии': {
    startMarker: '4. Ключевые Критерии Выбора Квартиры (Наиболее Важные и Частые)',
    endMarker: '5. "Квартира Мечты"',
    titleMatcher: /критерии|выбор квартиры/i
  },
  'Квартира Мечты': {
    startMarker: '5. "Квартира Мечты" (Усредненный Образ)',
    endMarker: '6. Ключевые Jobs-to-be-Done',
    titleMatcher: /квартира мечты/i
  },
  'Jobs-to-be-Done': {
    startMarker: '6. Ключевые Jobs-to-be-Done (Наиболее Характерные Job Stories)',
    endMarker: '7. Боли и Страхи',
    titleMatcher: /job|jtbd|джобы/i
  },
  'Боли и Страхи': {
    startMarker: '7. Боли и Страхи',
    endMarker: '8. Блокеры',
    titleMatcher: /боли|страхи/i
  },
  'Блокеры': {
    startMarker: '8. Блокеры',
    endMarker: '9. Ключевые Мотивы',
    titleMatcher: /блокеры/i
  },
  'Драйверы': {
    startMarker: '9. Ключевые Мотивы (Драйверы)',
    endMarker: '10. Триггеры',
    titleMatcher: /драйвер|мотив/i
  },
  'Триггеры': {
    startMarker: '10. Триггеры',
    endMarker: null, // конец документа
    titleMatcher: /триггер/i
  }
};

// Функция для показа диалога импорта
async function showImportDialog() {
  const modal = await miro.board.ui.openModal({
    url: 'import-dialog.html',
    width: 500,
    height: 400,
    title: 'Импорт данных из отчета ПИК'
  });
}

// Основная функция импорта
async function importFromPdf(file) {
  try {
    // Загрузка PDF.js для работы с PDF (в реальном проекте эту библиотеку нужно включить в плагин)
    const pdfjs = await loadPdfJs();
    
    // Чтение файла и преобразование PDF в текст
    const arrayBuffer = await file.arrayBuffer();
    const loadingTask = pdfjs.getDocument(arrayBuffer);
    const pdfDocument = await loadingTask.promise;
    
    const allText = await extractTextFromPdf(pdfDocument);
    
    // Извлечение разделов из текста
    const extractedSections = extractSectionsFromText(allText);
    
    // Обновление карточек в Miro
    await updateMiroCards(extractedSections);
    
    return {success: true, message: "Импорт успешно завершен"};
  } catch (error) {
    console.error("Ошибка импорта:", error);
    return {success: false, message: `Ошибка: ${error.message}`};
  }
}

// Функция для загрузки PDF.js
function loadPdfJs() {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js';
    script.onload = () => {
      const pdfjsLib = window['pdfjs-dist/build/pdf'];
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
      resolve(pdfjsLib);
    };
    script.onerror = () => reject(new Error('Не удалось загрузить PDF.js'));
    document.head.appendChild(script);
  });
}

// Функция для извлечения текста из PDF
async function extractTextFromPdf(pdfDocument) {
  let allText = '';
  
  for (let i = 1; i <= pdfDocument.numPages; i++) {
    const page = await pdfDocument.getPage(i);
    const textContent = await page.getTextContent();
    const strings = textContent.items.map(item => item.str);
    allText += strings.join(' ') + '\n';
  }
  
  return allText;
}

// Функция для извлечения разделов из текста
function extractSectionsFromText(text) {
  const extractedSections = {};
  
  for (const [sectionName, sectionConfig] of Object.entries(reportSections)) {
    const { startMarker, endMarker } = sectionConfig;
    
    // Находим начало секции
    const startIndex = text.indexOf(startMarker);
    if (startIndex === -1) continue;
    
    // Находим конец секции
    let endIndex;
    if (endMarker) {
      endIndex = text.indexOf(endMarker, startIndex);
      if (endIndex === -1) endIndex = text.length;
    } else {
      endIndex = text.length;
    }
    
    // Извлекаем содержимое секции
    let sectionContent = text.substring(startIndex + startMarker.length, endIndex).trim();
    
    // Очищаем от номеров страниц и других артефактов
    sectionContent = cleanupSectionContent(sectionContent);
    
    extractedSections[sectionName] = sectionContent;
  }
  
  return extractedSections;
}

// Функция для очистки содержимого секции
function cleanupSectionContent(content) {
  // Удаляем номера страниц и другие артефакты
  content = content.replace(/\d+\s+\/\s+\d+/g, '');
  
  // Удаляем лишние пробелы
  content = content.replace(/\s+/g, ' ');
  
  return content.trim();
}

// Функция для разделения контента на подразделы (для карточек)
function splitContentIntoSubsections(content) {
  // Разбиваем по подзаголовкам, которые часто начинаются с заглавных букв и заканчиваются двоеточием
  const subsectionRegex = /([А-Я][А-Яа-я\s]+):/g;
  const subsections = [];
  let match;
  let lastIndex = 0;
  
  while ((match = subsectionRegex.exec(content)) !== null) {
    const title = match[1].trim();
    const startIdx = match.index + match[0].length;
    
    // Для первого подраздела текст начинается с начала контента до этого подраздела
    if (subsections.length === 0 && match.index > 0) {
      subsections.push({
        title: 'Общее',
        content: content.substring(0, match.index).trim()
      });
    }
    
    // Если это не первое совпадение, добавляем предыдущий подраздел
    if (lastIndex > 0) {
      subsections.push({
        title: content.substring(lastIndex, match.index).match(subsectionRegex)[0].replace(':', '').trim(),
        content: content.substring(lastIndex + content.substring(lastIndex, match.index).match(subsectionRegex)[0].length, match.index).trim()
      });
    }
    
    lastIndex = startIdx;
  }
  
  // Добавляем последний подраздел
  if (lastIndex > 0 && lastIndex < content.length) {
    const lastTitle = content.substring(lastIndex - content.substring(0, lastIndex).match(/([А-Я][А-Яа-я\s]+):$/)?.length || 0, lastIndex).match(/([А-Я][А-Яа-я\s]+):$/)?.[1] || 'Дополнительно';
    subsections.push({
      title: lastTitle,
      content: content.substring(lastIndex).trim()
    });
  } else if (subsections.length === 0) {
    // Если нет подразделов, добавляем весь контент как один подраздел
    subsections.push({
      title: 'Общая информация',
      content: content.trim()
    });
  }
  
  return subsections;
}

// Функция для обновления карточек в Miro
async function updateMiroCards(sections) {
  // Получаем все текстовые карточки с доски Miro
  const cards = await miro.board.widgets.get({type: 'card'});
  const shapes = await miro.board.widgets.get({type: 'shape'});
  const texts = await miro.board.widgets.get({type: 'text'});
  const allWidgets = [...cards, ...shapes, ...texts];
  
  // Проходимся по каждому разделу
  for (const [sectionName, sectionContent] of Object.entries(sections)) {
    // Ищем соответствующие карточки на доске Miro
    const sectionConfig = reportSections[sectionName];
    const matchingWidgets = allWidgets.filter(widget => {
      const widgetText = widget.text || widget.title || (widget.plainText || '');
      return sectionConfig.titleMatcher.test(widgetText);
    });
    
    if (matchingWidgets.length > 0) {
      // Для каждой найденной карточки
      for (const widget of matchingWidgets) {
        // Если это карточка (card), обновляем её содержимое
        if (widget.type === 'card') {
          await miro.board.widgets.update({
            id: widget.id,
            description: sectionContent
          });
        } 
        // Если это текст или фигура, создаем новую карточку рядом
        else {
          // Для более удобного отображения данных разбиваем контент на подсекции
          const subsections = splitContentIntoSubsections(sectionContent);
          
          // Создаем новую карточку для каждой подсекции
          for (let i = 0; i < subsections.length; i++) {
            const subsection = subsections[i];
            await miro.board.widgets.create({
              type: 'card',
              title: `${sectionName}: ${subsection.title}`,
              description: subsection.content,
              x: widget.x + widget.width + 100 + (i * 220), // Размещаем карточки в ряд справа от исходного виджета
              y: widget.y,
              width: 200,
              style: {
                backgroundColor: getColorForSection(sectionName)
              }
            });
          }
        }
      }
    } else {
      // Если не нашли соответствующую карточку, создаем новую в центре доски
      const viewportInfo = await miro.board.viewport.get();
      const center = {
        x: viewportInfo.x + viewportInfo.width / 2,
        y: viewportInfo.y + viewportInfo.height / 2
      };
      
      await miro.board.widgets.create({
        type: 'card',
        title: sectionName,
        description: sectionContent,
        x: center.x,
        y: center.y,
        width: 300,
        style: {
          backgroundColor: getColorForSection(sectionName)
        }
      });
    }
  }
}

// Функция для определения цвета карточки в зависимости от типа раздела
function getColorForSection(sectionName) {
  const colorMap = {
    'Демография': '#ffcccc', // светло-красный
    'Поведение': '#ccffcc', // светло-зеленый
    'Психологический Портрет': '#ccccff', // светло-синий
    'Критерии': '#ffffcc', // светло-желтый
    'Квартира Мечты': '#ffccff', // светло-пурпурный
    'Jobs-to-be-Done': '#ccffff', // светло-голубой
    'Боли и Страхи': '#ffddcc', // персиковый
    'Блокеры': '#ddffcc', // светло-лаймовый
    'Драйверы': '#ffccdd', // светло-розовый
    'Триггеры': '#ccddff'  // светло-сиреневый
  };
  
  return colorMap[sectionName] || '#f5f5f5'; // если нет в списке, используем светло-серый
}

// Эта функция вызывается из диалогового окна, когда пользователь загрузил файл
async function handleFileUpload(file) {
  if (file.name.endsWith('.pdf') || file.name.endsWith('.docx')) {
    miro.showNotification({
      type: 'info',
      message: 'Начинаем импорт данных, пожалуйста подождите...'
    });
    
    const result = file.name.endsWith('.pdf') 
      ? await importFromPdf(file)
      : await importFromDocx(file);
    
    if (result.success) {
      miro.showNotification({
        type: 'success',
        message: result.message
      });
      miro.board.ui.closeModal();
    } else {
      miro.showNotification({
        type: 'error',
        message: result.message
      });
    }
  } else {
    miro.showNotification({
      type: 'error',
      message: 'Поддерживаются только файлы PDF или DOCX'
    });
  }
}

// Функция для импорта из DOCX (используя mammoth.js)
async function importFromDocx(file) {
  try {
    // Загрузка mammoth.js
    const mammoth = await loadMammoth();
    
    // Чтение файла и преобразование DOCX в HTML
    const arrayBuffer = await file.arrayBuffer();
    const result = await mammoth.convertToHtml({arrayBuffer});
    const html = result.value;
    
    // Извлечение текста из HTML
    const text = html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');
    
    // Извлечение разделов из текста
    const extractedSections = extractSectionsFromText(text);
    
    // Обновление карточек в Miro
    await updateMiroCards(extractedSections);
    
    return {success: true, message: "Импорт из DOCX успешно завершен"};
  } catch (error) {
    console.error("Ошибка импорта из DOCX:", error);
    return {success: false, message: `Ошибка при импорте из DOCX: ${error.message}`};
  }
}

// Функция для загрузки mammoth.js
function loadMammoth() {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.0/mammoth.browser.min.js';
    script.onload = () => resolve(window.mammoth);
    script.onerror = () => reject(new Error('Не удалось загрузить mammoth.js'));
    document.head.appendChild(script);
  });
}
